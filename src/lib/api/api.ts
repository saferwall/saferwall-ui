/* tslint:disable */
/* eslint-disable */
/**
 * Saferwall Web API
 * Interact with Saferwall Malware Analysis Platform
 *
 * The version of the OpenAPI document: 1.0
 * Contact: support@saferwall.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AuthConfirmAccountRequest
 */
export interface AuthConfirmAccountRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthConfirmAccountRequest
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface AuthCreateNewPwdRequest
 */
export interface AuthCreateNewPwdRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthCreateNewPwdRequest
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof AuthCreateNewPwdRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof AuthCreateNewPwdRequest
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface AuthLoginRequest
 */
export interface AuthLoginRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthLoginRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof AuthLoginRequest
     */
    'username': string;
}
/**
 * 
 * @export
 * @interface AuthResetPwdRequest
 */
export interface AuthResetPwdRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthResetPwdRequest
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface CommentCreateCommentRequest
 */
export interface CommentCreateCommentRequest {
    /**
     * 
     * @type {string}
     * @memberof CommentCreateCommentRequest
     */
    'body': string;
    /**
     * 
     * @type {string}
     * @memberof CommentCreateCommentRequest
     */
    'sha256': string;
    /**
     * 
     * @type {string}
     * @memberof CommentCreateCommentRequest
     */
    'username'?: string;
}
/**
 * 
 * @export
 * @interface CommentUpdateCommentRequest
 */
export interface CommentUpdateCommentRequest {
    /**
     * 
     * @type {string}
     * @memberof CommentUpdateCommentRequest
     */
    'body': string;
}
/**
 * 
 * @export
 * @interface CommentsGet200Response
 */
export interface CommentsGet200Response {
    /**
     * 
     * @type {Array<EntityComment>}
     * @memberof CommentsGet200Response
     */
    'items'?: Array<EntityComment>;
    /**
     * 
     * @type {number}
     * @memberof CommentsGet200Response
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof CommentsGet200Response
     */
    'page_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof CommentsGet200Response
     */
    'per_page'?: number;
    /**
     * 
     * @type {number}
     * @memberof CommentsGet200Response
     */
    'total_count'?: number;
}
/**
 * 
 * @export
 * @interface EntityBehavior
 */
export interface EntityBehavior {
    /**
     * 
     * @type {object}
     * @memberof EntityBehavior
     */
    'agent_log'?: object;
    /**
     * 
     * @type {object}
     * @memberof EntityBehavior
     */
    'api_trace'?: object;
    /**
     * 
     * @type {object}
     * @memberof EntityBehavior
     */
    'artifacts'?: object;
    /**
     * 
     * @type {object}
     * @memberof EntityBehavior
     */
    'capabilities'?: object;
    /**
     * 
     * @type {EntityDocMetadata}
     * @memberof EntityBehavior
     */
    'doc'?: EntityDocMetadata;
    /**
     * 
     * @type {object}
     * @memberof EntityBehavior
     */
    'env'?: object;
    /**
     * 
     * @type {object}
     * @memberof EntityBehavior
     */
    'proc_tree'?: object;
    /**
     * 
     * @type {object}
     * @memberof EntityBehavior
     */
    'sandbox_log'?: object;
    /**
     * 
     * @type {object}
     * @memberof EntityBehavior
     */
    'scan_cfg'?: object;
    /**
     * 
     * @type {number}
     * @memberof EntityBehavior
     */
    'screenshots_count'?: number;
    /**
     * 
     * @type {string}
     * @memberof EntityBehavior
     */
    'sha256'?: string;
    /**
     * 
     * @type {EntityFileScanProgressType}
     * @memberof EntityBehavior
     */
    'status'?: EntityFileScanProgressType;
    /**
     * 
     * @type {object}
     * @memberof EntityBehavior
     */
    'sys_events'?: object;
    /**
     * 
     * @type {number}
     * @memberof EntityBehavior
     */
    'timestamp'?: number;
    /**
     * 
     * @type {string}
     * @memberof EntityBehavior
     */
    'type'?: string;
}


/**
 * 
 * @export
 * @interface EntityComment
 */
export interface EntityComment {
    /**
     * Body represents the content of the comment.
     * @type {string}
     * @memberof EntityComment
     */
    'body'?: string;
    /**
     * Meta represents document metadata.
     * @type {EntityDocMetadata}
     * @memberof EntityComment
     */
    'doc'?: EntityDocMetadata;
    /**
     * ID represents the activity identifier.
     * @type {string}
     * @memberof EntityComment
     */
    'id'?: string;
    /**
     * SHA256 references the hash of the file where the comment has been made.
     * @type {string}
     * @memberof EntityComment
     */
    'sha256'?: string;
    /**
     * Timestamp when this activity happened.
     * @type {number}
     * @memberof EntityComment
     */
    'timestamp'?: number;
    /**
     * Type represents the document type.
     * @type {string}
     * @memberof EntityComment
     */
    'type'?: string;
    /**
     * Username represents the author of the comment.
     * @type {string}
     * @memberof EntityComment
     */
    'username'?: string;
}
/**
 * 
 * @export
 * @interface EntityDocMetadata
 */
export interface EntityDocMetadata {
    /**
     * 
     * @type {number}
     * @memberof EntityDocMetadata
     */
    'created_at'?: number;
    /**
     * 
     * @type {number}
     * @memberof EntityDocMetadata
     */
    'last_updated'?: number;
    /**
     * 
     * @type {number}
     * @memberof EntityDocMetadata
     */
    'version'?: number;
}
/**
 * 
 * @export
 * @interface EntityFile
 */
export interface EntityFile {
    /**
     * 
     * @type {object}
     * @memberof EntityFile
     */
    'behavior_scans'?: object;
    /**
     * 
     * @type {Array<number>}
     * @memberof EntityFile
     */
    'byte_entropy'?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof EntityFile
     */
    'crc32'?: string;
    /**
     * 
     * @type {object}
     * @memberof EntityFile
     */
    'default_behavior_report'?: object;
    /**
     * 
     * @type {EntityDocMetadata}
     * @memberof EntityFile
     */
    'doc'?: EntityDocMetadata;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof EntityFile
     */
    'exif'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof EntityFile
     */
    'file_extension'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityFile
     */
    'file_format'?: string;
    /**
     * 
     * @type {number}
     * @memberof EntityFile
     */
    'first_seen'?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof EntityFile
     */
    'histogram'?: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof EntityFile
     */
    'last_scanned'?: number;
    /**
     * 
     * @type {string}
     * @memberof EntityFile
     */
    'magic'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityFile
     */
    'md5'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof EntityFile
     */
    'ml'?: { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof EntityFile
     */
    'multiav'?: { [key: string]: any; };
    /**
     * 
     * @type {Array<string>}
     * @memberof EntityFile
     */
    'packer'?: Array<string>;
    /**
     * 
     * @type {object}
     * @memberof EntityFile
     */
    'pe'?: object;
    /**
     * 
     * @type {string}
     * @memberof EntityFile
     */
    'sha1'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityFile
     */
    'sha256'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityFile
     */
    'sha512'?: string;
    /**
     * 
     * @type {number}
     * @memberof EntityFile
     */
    'size'?: number;
    /**
     * 
     * @type {string}
     * @memberof EntityFile
     */
    'ssdeep'?: string;
    /**
     * 
     * @type {EntityFileScanProgressType}
     * @memberof EntityFile
     */
    'status'?: EntityFileScanProgressType;
    /**
     * 
     * @type {object}
     * @memberof EntityFile
     */
    'strings'?: object;
    /**
     * 
     * @type {Array<EntitySubmission>}
     * @memberof EntityFile
     */
    'submissions'?: Array<EntitySubmission>;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof EntityFile
     */
    'tags'?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof EntityFile
     */
    'tlsh'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof EntityFile
     */
    'trid'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof EntityFile
     */
    'type'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const EntityFileScanProgressType = {
    FileScanProgressQueued: 1,
    FileScanProgressProcessing: 2,
    FileScanProgressFinished: 3
} as const;

export type EntityFileScanProgressType = typeof EntityFileScanProgressType[keyof typeof EntityFileScanProgressType];


/**
 * 
 * @export
 * @interface EntitySubmission
 */
export interface EntitySubmission {
    /**
     * 
     * @type {string}
     * @memberof EntitySubmission
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntitySubmission
     */
    'filename'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntitySubmission
     */
    'src'?: string;
    /**
     * 
     * @type {number}
     * @memberof EntitySubmission
     */
    'timestamp'?: number;
}
/**
 * 
 * @export
 * @interface EntityUser
 */
export interface EntityUser {
    /**
     * 
     * @type {boolean}
     * @memberof EntityUser
     */
    'admin'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EntityUser
     */
    'bio'?: string;
    /**
     * 
     * @type {number}
     * @memberof EntityUser
     */
    'comments_count'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof EntityUser
     */
    'confirmed'?: boolean;
    /**
     * 
     * @type {EntityDocMetadata}
     * @memberof EntityUser
     */
    'doc'?: EntityDocMetadata;
    /**
     * 
     * @type {string}
     * @memberof EntityUser
     */
    'email'?: string;
    /**
     * 
     * @type {Array<EntityUserFollows>}
     * @memberof EntityUser
     */
    'followers'?: Array<EntityUserFollows>;
    /**
     * 
     * @type {Array<EntityUserFollows>}
     * @memberof EntityUser
     */
    'following'?: Array<EntityUserFollows>;
    /**
     * 
     * @type {number}
     * @memberof EntityUser
     */
    'last_seen'?: number;
    /**
     * 
     * @type {Array<EntityUserLike>}
     * @memberof EntityUser
     */
    'likes'?: Array<EntityUserLike>;
    /**
     * 
     * @type {string}
     * @memberof EntityUser
     */
    'location'?: string;
    /**
     * 
     * @type {number}
     * @memberof EntityUser
     */
    'member_since'?: number;
    /**
     * 
     * @type {string}
     * @memberof EntityUser
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityUser
     */
    'password'?: string;
    /**
     * 
     * @type {Array<EntityUserSubmission>}
     * @memberof EntityUser
     */
    'submissions'?: Array<EntityUserSubmission>;
    /**
     * 
     * @type {string}
     * @memberof EntityUser
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityUser
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityUser
     */
    'username'?: string;
}
/**
 * 
 * @export
 * @interface EntityUserFollows
 */
export interface EntityUserFollows {
    /**
     * 
     * @type {number}
     * @memberof EntityUserFollows
     */
    'ts'?: number;
    /**
     * 
     * @type {string}
     * @memberof EntityUserFollows
     */
    'username'?: string;
}
/**
 * 
 * @export
 * @interface EntityUserLike
 */
export interface EntityUserLike {
    /**
     * 
     * @type {string}
     * @memberof EntityUserLike
     */
    'sha256'?: string;
    /**
     * 
     * @type {number}
     * @memberof EntityUserLike
     */
    'ts'?: number;
}
/**
 * 
 * @export
 * @interface EntityUserSubmission
 */
export interface EntityUserSubmission {
    /**
     * 
     * @type {string}
     * @memberof EntityUserSubmission
     */
    'sha256'?: string;
    /**
     * 
     * @type {number}
     * @memberof EntityUserSubmission
     */
    'ts'?: number;
}
/**
 * 
 * @export
 * @interface ErrorsErrorResponse
 */
export interface ErrorsErrorResponse {
    /**
     * 
     * @type {object}
     * @memberof ErrorsErrorResponse
     */
    'details'?: object;
    /**
     * 
     * @type {string}
     * @memberof ErrorsErrorResponse
     */
    'message'?: string;
    /**
     * 
     * @type {number}
     * @memberof ErrorsErrorResponse
     */
    'status'?: number;
}
/**
 * 
 * @export
 * @interface FileAutoCompleteEntry
 */
export interface FileAutoCompleteEntry {
    /**
     * 
     * @type {string}
     * @memberof FileAutoCompleteEntry
     */
    'comment'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileAutoCompleteEntry
     */
    'query'?: string;
}
/**
 * 
 * @export
 * @interface FileFileSearchAutocomplete
 */
export interface FileFileSearchAutocomplete {
    /**
     * 
     * @type {Array<FileAutoCompleteEntry>}
     * @memberof FileFileSearchAutocomplete
     */
    'examples'?: Array<FileAutoCompleteEntry>;
    /**
     * 
     * @type {Array<FileAutoCompleteEntry>}
     * @memberof FileFileSearchAutocomplete
     */
    'search_modifiers'?: Array<FileAutoCompleteEntry>;
}
/**
 * 
 * @export
 * @interface FilesGet200Response
 */
export interface FilesGet200Response {
    /**
     * 
     * @type {Array<EntityFile>}
     * @memberof FilesGet200Response
     */
    'items'?: Array<EntityFile>;
    /**
     * 
     * @type {number}
     * @memberof FilesGet200Response
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof FilesGet200Response
     */
    'page_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof FilesGet200Response
     */
    'per_page'?: number;
    /**
     * 
     * @type {number}
     * @memberof FilesGet200Response
     */
    'total_count'?: number;
}
/**
 * 
 * @export
 * @interface PaginationPages
 */
export interface PaginationPages {
    /**
     * 
     * @type {object}
     * @memberof PaginationPages
     */
    'items'?: object;
    /**
     * 
     * @type {number}
     * @memberof PaginationPages
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginationPages
     */
    'page_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginationPages
     */
    'per_page'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginationPages
     */
    'total_count'?: number;
}
/**
 * 
 * @export
 * @interface UserCreateUserRequest
 */
export interface UserCreateUserRequest {
    /**
     * 
     * @type {string}
     * @memberof UserCreateUserRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserCreateUserRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof UserCreateUserRequest
     */
    'username': string;
}
/**
 * 
 * @export
 * @interface UserUpdateEmailRequest
 */
export interface UserUpdateEmailRequest {
    /**
     * 
     * @type {string}
     * @memberof UserUpdateEmailRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdateEmailRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface UserUpdateUserRequest
 */
export interface UserUpdateUserRequest {
    /**
     * 
     * @type {string}
     * @memberof UserUpdateUserRequest
     */
    'bio'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdateUserRequest
     */
    'location'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdateUserRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdateUserRequest
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface UsersGet200Response
 */
export interface UsersGet200Response {
    /**
     * 
     * @type {Array<EntityUser>}
     * @memberof UsersGet200Response
     */
    'items'?: Array<EntityUser>;
    /**
     * 
     * @type {number}
     * @memberof UsersGet200Response
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof UsersGet200Response
     */
    'page_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof UsersGet200Response
     */
    'per_page'?: number;
    /**
     * 
     * @type {number}
     * @memberof UsersGet200Response
     */
    'total_count'?: number;
}

/**
 * ActivityApi - axios parameter creator
 * @export
 */
export const ActivityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List of activities of a user.
         * @summary Returns a paginated list of a user\'s activities
         * @param {number} [perPage] Number of items per page
         * @param {number} [page] Specify the page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersActivitiesGet: async (perPage?: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/activities/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Bearer", [], configuration)

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActivityApi - functional programming interface
 * @export
 */
export const ActivityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActivityApiAxiosParamCreator(configuration)
    return {
        /**
         * List of activities of a user.
         * @summary Returns a paginated list of a user\'s activities
         * @param {number} [perPage] Number of items per page
         * @param {number} [page] Specify the page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersActivitiesGet(perPage?: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationPages>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersActivitiesGet(perPage, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActivityApi.usersActivitiesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ActivityApi - factory interface
 * @export
 */
export const ActivityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActivityApiFp(configuration)
    return {
        /**
         * List of activities of a user.
         * @summary Returns a paginated list of a user\'s activities
         * @param {number} [perPage] Number of items per page
         * @param {number} [page] Specify the page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersActivitiesGet(perPage?: number, page?: number, options?: any): AxiosPromise<PaginationPages> {
            return localVarFp.usersActivitiesGet(perPage, page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActivityApi - object-oriented interface
 * @export
 * @class ActivityApi
 * @extends {BaseAPI}
 */
export class ActivityApi extends BaseAPI {
    /**
     * List of activities of a user.
     * @summary Returns a paginated list of a user\'s activities
     * @param {number} [perPage] Number of items per page
     * @param {number} [page] Specify the page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityApi
     */
    public usersActivitiesGet(perPage?: number, page?: number, options?: RawAxiosRequestConfig) {
        return ActivityApiFp(this.configuration).usersActivitiesGet(perPage, page, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Users logins by username and password.
         * @summary Log in
         * @param {AuthLoginRequest} authRequest Username and password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLoginPost: async (authRequest: AuthLoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authRequest' is not null or undefined
            assertParamExists('authLoginPost', 'authRequest', authRequest)
            const localVarPath = `/auth/login/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the cookie used for authentication.
         * @summary Log out from current session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLogoutDelete: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/logout/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the password from the auth token received in email.
         * @summary Create a new password from a token received in email
         * @param {AuthCreateNewPwdRequest} resetPwd New password request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authPasswordPost: async (resetPwd: AuthCreateNewPwdRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resetPwd' is not null or undefined
            assertParamExists('authPasswordPost', 'resetPwd', resetPwd)
            const localVarPath = `/auth/password/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetPwd, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send a new confirmation email link to confirm user\'s account.
         * @summary Resend a confirmation email
         * @param {AuthConfirmAccountRequest} resetPwd Account confirmation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authResendConfirmationPost: async (resetPwd: AuthConfirmAccountRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resetPwd' is not null or undefined
            assertParamExists('authResendConfirmationPost', 'resetPwd', resetPwd)
            const localVarPath = `/auth/resend-confirmation/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetPwd, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request a reset password for anonymous users.
         * @summary Reset password for non-logged users by email
         * @param {AuthResetPwdRequest} resetPwd Email used during account sign-up
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authResetPasswordPost: async (resetPwd: AuthResetPwdRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resetPwd' is not null or undefined
            assertParamExists('authResetPasswordPost', 'resetPwd', resetPwd)
            const localVarPath = `/auth/reset-password/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetPwd, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verify the JWT token received during account creation.
         * @summary Confirm a new account creation
         * @param {string} guid GUID to identify the token
         * @param {string} token JWT token generated for account creation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authVerifyAccountGet: async (guid: string, token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('authVerifyAccountGet', 'guid', guid)
            // verify required parameter 'token' is not null or undefined
            assertParamExists('authVerifyAccountGet', 'token', token)
            const localVarPath = `/auth/verify-account/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (guid !== undefined) {
                localVarQueryParameter['guid'] = guid;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * Users logins by username and password.
         * @summary Log in
         * @param {AuthLoginRequest} authRequest Username and password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authLoginPost(authRequest: AuthLoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authLoginPost(authRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authLoginPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete the cookie used for authentication.
         * @summary Log out from current session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authLogoutDelete(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authLogoutDelete(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authLogoutDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the password from the auth token received in email.
         * @summary Create a new password from a token received in email
         * @param {AuthCreateNewPwdRequest} resetPwd New password request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authPasswordPost(resetPwd: AuthCreateNewPwdRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authPasswordPost(resetPwd, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authPasswordPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send a new confirmation email link to confirm user\'s account.
         * @summary Resend a confirmation email
         * @param {AuthConfirmAccountRequest} resetPwd Account confirmation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authResendConfirmationPost(resetPwd: AuthConfirmAccountRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authResendConfirmationPost(resetPwd, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authResendConfirmationPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Request a reset password for anonymous users.
         * @summary Reset password for non-logged users by email
         * @param {AuthResetPwdRequest} resetPwd Email used during account sign-up
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authResetPasswordPost(resetPwd: AuthResetPwdRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authResetPasswordPost(resetPwd, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authResetPasswordPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Verify the JWT token received during account creation.
         * @summary Confirm a new account creation
         * @param {string} guid GUID to identify the token
         * @param {string} token JWT token generated for account creation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authVerifyAccountGet(guid: string, token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authVerifyAccountGet(guid, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authVerifyAccountGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * Users logins by username and password.
         * @summary Log in
         * @param {AuthLoginRequest} authRequest Username and password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLoginPost(authRequest: AuthLoginRequest, options?: any): AxiosPromise<string> {
            return localVarFp.authLoginPost(authRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete the cookie used for authentication.
         * @summary Log out from current session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLogoutDelete(options?: any): AxiosPromise<void> {
            return localVarFp.authLogoutDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * Update the password from the auth token received in email.
         * @summary Create a new password from a token received in email
         * @param {AuthCreateNewPwdRequest} resetPwd New password request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authPasswordPost(resetPwd: AuthCreateNewPwdRequest, options?: any): AxiosPromise<string> {
            return localVarFp.authPasswordPost(resetPwd, options).then((request) => request(axios, basePath));
        },
        /**
         * Send a new confirmation email link to confirm user\'s account.
         * @summary Resend a confirmation email
         * @param {AuthConfirmAccountRequest} resetPwd Account confirmation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authResendConfirmationPost(resetPwd: AuthConfirmAccountRequest, options?: any): AxiosPromise<string> {
            return localVarFp.authResendConfirmationPost(resetPwd, options).then((request) => request(axios, basePath));
        },
        /**
         * Request a reset password for anonymous users.
         * @summary Reset password for non-logged users by email
         * @param {AuthResetPwdRequest} resetPwd Email used during account sign-up
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authResetPasswordPost(resetPwd: AuthResetPwdRequest, options?: any): AxiosPromise<string> {
            return localVarFp.authResetPasswordPost(resetPwd, options).then((request) => request(axios, basePath));
        },
        /**
         * Verify the JWT token received during account creation.
         * @summary Confirm a new account creation
         * @param {string} guid GUID to identify the token
         * @param {string} token JWT token generated for account creation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authVerifyAccountGet(guid: string, token: string, options?: any): AxiosPromise<string> {
            return localVarFp.authVerifyAccountGet(guid, token, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * Users logins by username and password.
     * @summary Log in
     * @param {AuthLoginRequest} authRequest Username and password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authLoginPost(authRequest: AuthLoginRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authLoginPost(authRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete the cookie used for authentication.
     * @summary Log out from current session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authLogoutDelete(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authLogoutDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the password from the auth token received in email.
     * @summary Create a new password from a token received in email
     * @param {AuthCreateNewPwdRequest} resetPwd New password request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authPasswordPost(resetPwd: AuthCreateNewPwdRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authPasswordPost(resetPwd, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send a new confirmation email link to confirm user\'s account.
     * @summary Resend a confirmation email
     * @param {AuthConfirmAccountRequest} resetPwd Account confirmation request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authResendConfirmationPost(resetPwd: AuthConfirmAccountRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authResendConfirmationPost(resetPwd, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Request a reset password for anonymous users.
     * @summary Reset password for non-logged users by email
     * @param {AuthResetPwdRequest} resetPwd Email used during account sign-up
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authResetPasswordPost(resetPwd: AuthResetPwdRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authResetPasswordPost(resetPwd, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verify the JWT token received during account creation.
     * @summary Confirm a new account creation
     * @param {string} guid GUID to identify the token
     * @param {string} token JWT token generated for account creation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authVerifyAccountGet(guid: string, token: string, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authVerifyAccountGet(guid, token, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BehaviorApi - axios parameter creator
 * @export
 */
export const BehaviorApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Paginates over the list of APIs
         * @summary List of APIs log.
         * @param {string} id Behavior report GUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        behaviorsIdApiTraceGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('behaviorsIdApiTraceGet', 'id', id)
            const localVarPath = `/behaviors/{id}/api-trace/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of artifacts\' metadata such as memdumps, created files, etc ..
         * @summary List of artifacts\' metadata.
         * @param {string} id Behavior report GUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        behaviorsIdArtifactsGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('behaviorsIdArtifactsGet', 'id', id)
            const localVarPath = `/behaviors/{id}/artifacts/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the full behavior report of a file.
         * @summary Check a behavior report.
         * @param {string} id Behavior report GUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        behaviorsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('behaviorsIdGet', 'id', id)
            const localVarPath = `/behaviors/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Paginates over the list of system events.
         * @summary List of system events.
         * @param {string} id Behavior report GUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        behaviorsIdSysEventsGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('behaviorsIdSysEventsGet', 'id', id)
            const localVarPath = `/behaviors/{id}/sys-events/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BehaviorApi - functional programming interface
 * @export
 */
export const BehaviorApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BehaviorApiAxiosParamCreator(configuration)
    return {
        /**
         * Paginates over the list of APIs
         * @summary List of APIs log.
         * @param {string} id Behavior report GUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async behaviorsIdApiTraceGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationPages>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.behaviorsIdApiTraceGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BehaviorApi.behaviorsIdApiTraceGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a paginated list of artifacts\' metadata such as memdumps, created files, etc ..
         * @summary List of artifacts\' metadata.
         * @param {string} id Behavior report GUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async behaviorsIdArtifactsGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.behaviorsIdArtifactsGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BehaviorApi.behaviorsIdArtifactsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the full behavior report of a file.
         * @summary Check a behavior report.
         * @param {string} id Behavior report GUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async behaviorsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityBehavior>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.behaviorsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BehaviorApi.behaviorsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Paginates over the list of system events.
         * @summary List of system events.
         * @param {string} id Behavior report GUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async behaviorsIdSysEventsGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationPages>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.behaviorsIdSysEventsGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BehaviorApi.behaviorsIdSysEventsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BehaviorApi - factory interface
 * @export
 */
export const BehaviorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BehaviorApiFp(configuration)
    return {
        /**
         * Paginates over the list of APIs
         * @summary List of APIs log.
         * @param {string} id Behavior report GUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        behaviorsIdApiTraceGet(id: string, options?: any): AxiosPromise<PaginationPages> {
            return localVarFp.behaviorsIdApiTraceGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of artifacts\' metadata such as memdumps, created files, etc ..
         * @summary List of artifacts\' metadata.
         * @param {string} id Behavior report GUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        behaviorsIdArtifactsGet(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.behaviorsIdArtifactsGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the full behavior report of a file.
         * @summary Check a behavior report.
         * @param {string} id Behavior report GUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        behaviorsIdGet(id: string, options?: any): AxiosPromise<EntityBehavior> {
            return localVarFp.behaviorsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Paginates over the list of system events.
         * @summary List of system events.
         * @param {string} id Behavior report GUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        behaviorsIdSysEventsGet(id: string, options?: any): AxiosPromise<PaginationPages> {
            return localVarFp.behaviorsIdSysEventsGet(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BehaviorApi - object-oriented interface
 * @export
 * @class BehaviorApi
 * @extends {BaseAPI}
 */
export class BehaviorApi extends BaseAPI {
    /**
     * Paginates over the list of APIs
     * @summary List of APIs log.
     * @param {string} id Behavior report GUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BehaviorApi
     */
    public behaviorsIdApiTraceGet(id: string, options?: RawAxiosRequestConfig) {
        return BehaviorApiFp(this.configuration).behaviorsIdApiTraceGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of artifacts\' metadata such as memdumps, created files, etc ..
     * @summary List of artifacts\' metadata.
     * @param {string} id Behavior report GUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BehaviorApi
     */
    public behaviorsIdArtifactsGet(id: string, options?: RawAxiosRequestConfig) {
        return BehaviorApiFp(this.configuration).behaviorsIdArtifactsGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the full behavior report of a file.
     * @summary Check a behavior report.
     * @param {string} id Behavior report GUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BehaviorApi
     */
    public behaviorsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return BehaviorApiFp(this.configuration).behaviorsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Paginates over the list of system events.
     * @summary List of system events.
     * @param {string} id Behavior report GUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BehaviorApi
     */
    public behaviorsIdSysEventsGet(id: string, options?: RawAxiosRequestConfig) {
        return BehaviorApiFp(this.configuration).behaviorsIdSysEventsGet(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CommentApi - axios parameter creator
 * @export
 */
export const CommentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List comments
         * @summary Retrieves a paginated list of comments
         * @param {number} [perPage] Number of comments  per page
         * @param {number} [page] Specify the page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsGet: async (perPage?: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/comments/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a comment by ID.
         * @summary Deletes a comment
         * @param {string} id Comment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('commentsIdDelete', 'id', id)
            const localVarPath = `/comments/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Bearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves information about a comment.
         * @summary Get comment by ID
         * @param {string} id Comment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('commentsIdGet', 'id', id)
            const localVarPath = `/comments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace a cocument with a new comment\'s document.
         * @summary Update a comment object (full update)
         * @param {string} id Comment ID
         * @param {CommentUpdateCommentRequest} data New comment data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsIdPatch: async (id: string, data: CommentUpdateCommentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('commentsIdPatch', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('commentsIdPatch', 'data', data)
            const localVarPath = `/comments/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Bearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new comment.
         * @summary Create a new comment
         * @param {CommentCreateCommentRequest} data Comment body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsPost: async (data: CommentCreateCommentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('commentsPost', 'data', data)
            const localVarPath = `/comments/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Bearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CommentApi - functional programming interface
 * @export
 */
export const CommentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CommentApiAxiosParamCreator(configuration)
    return {
        /**
         * List comments
         * @summary Retrieves a paginated list of comments
         * @param {number} [perPage] Number of comments  per page
         * @param {number} [page] Specify the page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commentsGet(perPage?: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommentsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commentsGet(perPage, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommentApi.commentsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a comment by ID.
         * @summary Deletes a comment
         * @param {string} id Comment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commentsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityComment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commentsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommentApi.commentsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves information about a comment.
         * @summary Get comment by ID
         * @param {string} id Comment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commentsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityComment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commentsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommentApi.commentsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Replace a cocument with a new comment\'s document.
         * @summary Update a comment object (full update)
         * @param {string} id Comment ID
         * @param {CommentUpdateCommentRequest} data New comment data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commentsIdPatch(id: string, data: CommentUpdateCommentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityComment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commentsIdPatch(id, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommentApi.commentsIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new comment.
         * @summary Create a new comment
         * @param {CommentCreateCommentRequest} data Comment body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commentsPost(data: CommentCreateCommentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityComment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commentsPost(data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommentApi.commentsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CommentApi - factory interface
 * @export
 */
export const CommentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CommentApiFp(configuration)
    return {
        /**
         * List comments
         * @summary Retrieves a paginated list of comments
         * @param {number} [perPage] Number of comments  per page
         * @param {number} [page] Specify the page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsGet(perPage?: number, page?: number, options?: any): AxiosPromise<CommentsGet200Response> {
            return localVarFp.commentsGet(perPage, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a comment by ID.
         * @summary Deletes a comment
         * @param {string} id Comment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsIdDelete(id: string, options?: any): AxiosPromise<EntityComment> {
            return localVarFp.commentsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves information about a comment.
         * @summary Get comment by ID
         * @param {string} id Comment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsIdGet(id: string, options?: any): AxiosPromise<EntityComment> {
            return localVarFp.commentsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace a cocument with a new comment\'s document.
         * @summary Update a comment object (full update)
         * @param {string} id Comment ID
         * @param {CommentUpdateCommentRequest} data New comment data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsIdPatch(id: string, data: CommentUpdateCommentRequest, options?: any): AxiosPromise<EntityComment> {
            return localVarFp.commentsIdPatch(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new comment.
         * @summary Create a new comment
         * @param {CommentCreateCommentRequest} data Comment body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsPost(data: CommentCreateCommentRequest, options?: any): AxiosPromise<EntityComment> {
            return localVarFp.commentsPost(data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CommentApi - object-oriented interface
 * @export
 * @class CommentApi
 * @extends {BaseAPI}
 */
export class CommentApi extends BaseAPI {
    /**
     * List comments
     * @summary Retrieves a paginated list of comments
     * @param {number} [perPage] Number of comments  per page
     * @param {number} [page] Specify the page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentApi
     */
    public commentsGet(perPage?: number, page?: number, options?: RawAxiosRequestConfig) {
        return CommentApiFp(this.configuration).commentsGet(perPage, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a comment by ID.
     * @summary Deletes a comment
     * @param {string} id Comment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentApi
     */
    public commentsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return CommentApiFp(this.configuration).commentsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves information about a comment.
     * @summary Get comment by ID
     * @param {string} id Comment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentApi
     */
    public commentsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return CommentApiFp(this.configuration).commentsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace a cocument with a new comment\'s document.
     * @summary Update a comment object (full update)
     * @param {string} id Comment ID
     * @param {CommentUpdateCommentRequest} data New comment data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentApi
     */
    public commentsIdPatch(id: string, data: CommentUpdateCommentRequest, options?: RawAxiosRequestConfig) {
        return CommentApiFp(this.configuration).commentsIdPatch(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new comment.
     * @summary Create a new comment
     * @param {CommentCreateCommentRequest} data Comment body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentApi
     */
    public commentsPost(data: CommentCreateCommentRequest, options?: RawAxiosRequestConfig) {
        return CommentApiFp(this.configuration).commentsPost(data, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FileApi - axios parameter creator
 * @export
 */
export const FileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List files
         * @summary Retrieves a paginated list of files
         * @param {number} [perPage] Number of files per page
         * @param {number} [page] Specify the page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesGet: async (perPage?: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/files/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Bearer", [], configuration)

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload file for analysis.
         * @summary Submit a new file for scanning
         * @param {File} file binary file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesPost: async (file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('filesPost', 'file', file)
            const localVarPath = `/files/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Bearer", [], configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * File search autocomplete.
         * @summary Returns a list of file search autocomplete data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesSearchAutocompleteGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/files/search/autocomplete/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search files
         * @summary Searches files based on files\' metadata
         * @param {number} [perPage] Number of files per page
         * @param {number} [page] Specify the page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesSearchPost: async (perPage?: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/files/search/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Bearer", [], configuration)

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of comments for a given file.
         * @summary Returns a paginated list of file comments
         * @param {string} sha256 File SHA256
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesSha256CommentsGet: async (sha256: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sha256' is not null or undefined
            assertParamExists('filesSha256CommentsGet', 'sha256', sha256)
            const localVarPath = `/files/{sha256}/comments/`
                .replace(`{${"sha256"}}`, encodeURIComponent(String(sha256)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Bearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a file by ID.
         * @summary Deletes a file
         * @param {string} sha256 File SHA256
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesSha256Delete: async (sha256: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sha256' is not null or undefined
            assertParamExists('filesSha256Delete', 'sha256', sha256)
            const localVarPath = `/files/{sha256}`
                .replace(`{${"sha256"}}`, encodeURIComponent(String(sha256)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Bearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Download a binary file. Files are in zip format and password protected.
         * @summary Download a file
         * @param {string} sha256 File SHA256
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesSha256DownloadGet: async (sha256: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sha256' is not null or undefined
            assertParamExists('filesSha256DownloadGet', 'sha256', sha256)
            const localVarPath = `/files/{sha256}/download/`
                .replace(`{${"sha256"}}`, encodeURIComponent(String(sha256)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Bearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate a pre-signed URL to download samples directly from the object storage.
         * @summary Generate a pre-signed URL for downloading samples.
         * @param {string} sha256 File SHA256
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesSha256GeneratePresignedUrlPost: async (sha256: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sha256' is not null or undefined
            assertParamExists('filesSha256GeneratePresignedUrlPost', 'sha256', sha256)
            const localVarPath = `/files/{sha256}/generate-presigned-url/`
                .replace(`{${"sha256"}}`, encodeURIComponent(String(sha256)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Bearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the content of a file report.
         * @summary Get a file report
         * @param {string} sha256 File SHA256
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesSha256Get: async (sha256: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sha256' is not null or undefined
            assertParamExists('filesSha256Get', 'sha256', sha256)
            const localVarPath = `/files/{sha256}`
                .replace(`{${"sha256"}}`, encodeURIComponent(String(sha256)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check weather a file exists in the database.
         * @summary Check if a file exists.
         * @param {string} sha256 File SHA256
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesSha256Head: async (sha256: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sha256' is not null or undefined
            assertParamExists('filesSha256Head', 'sha256', sha256)
            const localVarPath = `/files/{sha256}`
                .replace(`{${"sha256"}}`, encodeURIComponent(String(sha256)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a file to the like list.
         * @summary Like a file
         * @param {string} sha256 File SHA256
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesSha256LikePost: async (sha256: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sha256' is not null or undefined
            assertParamExists('filesSha256LikePost', 'sha256', sha256)
            const localVarPath = `/files/{sha256}/like/`
                .replace(`{${"sha256"}}`, encodeURIComponent(String(sha256)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Bearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Frontend metadata fields such as navbar menus.
         * @summary Frontend Metadata
         * @param {string} sha256 File SHA256
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesSha256MetaUiGet: async (sha256: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sha256' is not null or undefined
            assertParamExists('filesSha256MetaUiGet', 'sha256', sha256)
            const localVarPath = `/files/{sha256}/meta-ui/`
                .replace(`{${"sha256"}}`, encodeURIComponent(String(sha256)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Bearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Patch a portion of a file report.
         * @summary Update a file report (partial update)
         * @param {string} sha256 File SHA256
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesSha256Patch: async (sha256: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sha256' is not null or undefined
            assertParamExists('filesSha256Patch', 'sha256', sha256)
            const localVarPath = `/files/{sha256}`
                .replace(`{${"sha256"}}`, encodeURIComponent(String(sha256)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Bearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace a file report with a new report
         * @summary Update a file report (full update)
         * @param {string} sha256 File SHA256
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesSha256Put: async (sha256: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sha256' is not null or undefined
            assertParamExists('filesSha256Put', 'sha256', sha256)
            const localVarPath = `/files/{sha256}`
                .replace(`{${"sha256"}}`, encodeURIComponent(String(sha256)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Bearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Rescan an existing file.
         * @summary Rescan an existing file
         * @param {string} sha256 File SHA256
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesSha256RescanPost: async (sha256: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sha256' is not null or undefined
            assertParamExists('filesSha256RescanPost', 'sha256', sha256)
            const localVarPath = `/files/{sha256}/rescan/`
                .replace(`{${"sha256"}}`, encodeURIComponent(String(sha256)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Bearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List strings of a file.
         * @summary Returns a paginated list of strings
         * @param {string} sha256 File SHA256
         * @param {number} [perPage] Number of strings per page
         * @param {number} [page] Specify the page number
         * @param {string} [q] Specify the string to search for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesSha256StringsGet: async (sha256: string, perPage?: number, page?: number, q?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sha256' is not null or undefined
            assertParamExists('filesSha256StringsGet', 'sha256', sha256)
            const localVarPath = `/files/{sha256}/strings/`
                .replace(`{${"sha256"}}`, encodeURIComponent(String(sha256)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * File metadata returned in the summary view of a file.
         * @summary File summary and metadata
         * @param {string} sha256 File SHA256
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesSha256SummaryGet: async (sha256: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sha256' is not null or undefined
            assertParamExists('filesSha256SummaryGet', 'sha256', sha256)
            const localVarPath = `/files/{sha256}/summary/`
                .replace(`{${"sha256"}}`, encodeURIComponent(String(sha256)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Bearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a file from the like list.
         * @summary Unlike a file
         * @param {string} sha256 File SHA256
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesSha256UnlikePost: async (sha256: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sha256' is not null or undefined
            assertParamExists('filesSha256UnlikePost', 'sha256', sha256)
            const localVarPath = `/files/{sha256}/unlike/`
                .replace(`{${"sha256"}}`, encodeURIComponent(String(sha256)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Bearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FileApi - functional programming interface
 * @export
 */
export const FileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FileApiAxiosParamCreator(configuration)
    return {
        /**
         * List files
         * @summary Retrieves a paginated list of files
         * @param {number} [perPage] Number of files per page
         * @param {number} [page] Specify the page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesGet(perPage?: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesGet(perPage, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileApi.filesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload file for analysis.
         * @summary Submit a new file for scanning
         * @param {File} file binary file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesPost(file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesPost(file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileApi.filesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * File search autocomplete.
         * @summary Returns a list of file search autocomplete data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesSearchAutocompleteGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileFileSearchAutocomplete>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesSearchAutocompleteGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileApi.filesSearchAutocompleteGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search files
         * @summary Searches files based on files\' metadata
         * @param {number} [perPage] Number of files per page
         * @param {number} [page] Specify the page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesSearchPost(perPage?: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationPages>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesSearchPost(perPage, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileApi.filesSearchPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List of comments for a given file.
         * @summary Returns a paginated list of file comments
         * @param {string} sha256 File SHA256
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesSha256CommentsGet(sha256: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationPages>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesSha256CommentsGet(sha256, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileApi.filesSha256CommentsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a file by ID.
         * @summary Deletes a file
         * @param {string} sha256 File SHA256
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesSha256Delete(sha256: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesSha256Delete(sha256, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileApi.filesSha256Delete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Download a binary file. Files are in zip format and password protected.
         * @summary Download a file
         * @param {string} sha256 File SHA256
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesSha256DownloadGet(sha256: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesSha256DownloadGet(sha256, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileApi.filesSha256DownloadGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generate a pre-signed URL to download samples directly from the object storage.
         * @summary Generate a pre-signed URL for downloading samples.
         * @param {string} sha256 File SHA256
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesSha256GeneratePresignedUrlPost(sha256: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesSha256GeneratePresignedUrlPost(sha256, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileApi.filesSha256GeneratePresignedUrlPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the content of a file report.
         * @summary Get a file report
         * @param {string} sha256 File SHA256
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesSha256Get(sha256: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesSha256Get(sha256, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileApi.filesSha256Get']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Check weather a file exists in the database.
         * @summary Check if a file exists.
         * @param {string} sha256 File SHA256
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesSha256Head(sha256: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesSha256Head(sha256, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileApi.filesSha256Head']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Adds a file to the like list.
         * @summary Like a file
         * @param {string} sha256 File SHA256
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesSha256LikePost(sha256: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesSha256LikePost(sha256, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileApi.filesSha256LikePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Frontend metadata fields such as navbar menus.
         * @summary Frontend Metadata
         * @param {string} sha256 File SHA256
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesSha256MetaUiGet(sha256: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesSha256MetaUiGet(sha256, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileApi.filesSha256MetaUiGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Patch a portion of a file report.
         * @summary Update a file report (partial update)
         * @param {string} sha256 File SHA256
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesSha256Patch(sha256: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesSha256Patch(sha256, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileApi.filesSha256Patch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Replace a file report with a new report
         * @summary Update a file report (full update)
         * @param {string} sha256 File SHA256
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesSha256Put(sha256: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesSha256Put(sha256, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileApi.filesSha256Put']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Rescan an existing file.
         * @summary Rescan an existing file
         * @param {string} sha256 File SHA256
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesSha256RescanPost(sha256: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesSha256RescanPost(sha256, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileApi.filesSha256RescanPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List strings of a file.
         * @summary Returns a paginated list of strings
         * @param {string} sha256 File SHA256
         * @param {number} [perPage] Number of strings per page
         * @param {number} [page] Specify the page number
         * @param {string} [q] Specify the string to search for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesSha256StringsGet(sha256: string, perPage?: number, page?: number, q?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationPages>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesSha256StringsGet(sha256, perPage, page, q, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileApi.filesSha256StringsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * File metadata returned in the summary view of a file.
         * @summary File summary and metadata
         * @param {string} sha256 File SHA256
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesSha256SummaryGet(sha256: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationPages>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesSha256SummaryGet(sha256, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileApi.filesSha256SummaryGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes a file from the like list.
         * @summary Unlike a file
         * @param {string} sha256 File SHA256
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesSha256UnlikePost(sha256: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesSha256UnlikePost(sha256, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileApi.filesSha256UnlikePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FileApi - factory interface
 * @export
 */
export const FileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FileApiFp(configuration)
    return {
        /**
         * List files
         * @summary Retrieves a paginated list of files
         * @param {number} [perPage] Number of files per page
         * @param {number} [page] Specify the page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesGet(perPage?: number, page?: number, options?: any): AxiosPromise<FilesGet200Response> {
            return localVarFp.filesGet(perPage, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload file for analysis.
         * @summary Submit a new file for scanning
         * @param {File} file binary file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesPost(file: File, options?: any): AxiosPromise<EntityFile> {
            return localVarFp.filesPost(file, options).then((request) => request(axios, basePath));
        },
        /**
         * File search autocomplete.
         * @summary Returns a list of file search autocomplete data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesSearchAutocompleteGet(options?: any): AxiosPromise<FileFileSearchAutocomplete> {
            return localVarFp.filesSearchAutocompleteGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Search files
         * @summary Searches files based on files\' metadata
         * @param {number} [perPage] Number of files per page
         * @param {number} [page] Specify the page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesSearchPost(perPage?: number, page?: number, options?: any): AxiosPromise<PaginationPages> {
            return localVarFp.filesSearchPost(perPage, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List of comments for a given file.
         * @summary Returns a paginated list of file comments
         * @param {string} sha256 File SHA256
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesSha256CommentsGet(sha256: string, options?: any): AxiosPromise<PaginationPages> {
            return localVarFp.filesSha256CommentsGet(sha256, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a file by ID.
         * @summary Deletes a file
         * @param {string} sha256 File SHA256
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesSha256Delete(sha256: string, options?: any): AxiosPromise<EntityFile> {
            return localVarFp.filesSha256Delete(sha256, options).then((request) => request(axios, basePath));
        },
        /**
         * Download a binary file. Files are in zip format and password protected.
         * @summary Download a file
         * @param {string} sha256 File SHA256
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesSha256DownloadGet(sha256: string, options?: any): AxiosPromise<void> {
            return localVarFp.filesSha256DownloadGet(sha256, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate a pre-signed URL to download samples directly from the object storage.
         * @summary Generate a pre-signed URL for downloading samples.
         * @param {string} sha256 File SHA256
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesSha256GeneratePresignedUrlPost(sha256: string, options?: any): AxiosPromise<object> {
            return localVarFp.filesSha256GeneratePresignedUrlPost(sha256, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the content of a file report.
         * @summary Get a file report
         * @param {string} sha256 File SHA256
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesSha256Get(sha256: string, options?: any): AxiosPromise<EntityFile> {
            return localVarFp.filesSha256Get(sha256, options).then((request) => request(axios, basePath));
        },
        /**
         * Check weather a file exists in the database.
         * @summary Check if a file exists.
         * @param {string} sha256 File SHA256
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesSha256Head(sha256: string, options?: any): AxiosPromise<EntityFile> {
            return localVarFp.filesSha256Head(sha256, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a file to the like list.
         * @summary Like a file
         * @param {string} sha256 File SHA256
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesSha256LikePost(sha256: string, options?: any): AxiosPromise<object> {
            return localVarFp.filesSha256LikePost(sha256, options).then((request) => request(axios, basePath));
        },
        /**
         * Frontend metadata fields such as navbar menus.
         * @summary Frontend Metadata
         * @param {string} sha256 File SHA256
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesSha256MetaUiGet(sha256: string, options?: any): AxiosPromise<object> {
            return localVarFp.filesSha256MetaUiGet(sha256, options).then((request) => request(axios, basePath));
        },
        /**
         * Patch a portion of a file report.
         * @summary Update a file report (partial update)
         * @param {string} sha256 File SHA256
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesSha256Patch(sha256: string, options?: any): AxiosPromise<EntityFile> {
            return localVarFp.filesSha256Patch(sha256, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace a file report with a new report
         * @summary Update a file report (full update)
         * @param {string} sha256 File SHA256
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesSha256Put(sha256: string, options?: any): AxiosPromise<EntityFile> {
            return localVarFp.filesSha256Put(sha256, options).then((request) => request(axios, basePath));
        },
        /**
         * Rescan an existing file.
         * @summary Rescan an existing file
         * @param {string} sha256 File SHA256
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesSha256RescanPost(sha256: string, options?: any): AxiosPromise<object> {
            return localVarFp.filesSha256RescanPost(sha256, options).then((request) => request(axios, basePath));
        },
        /**
         * List strings of a file.
         * @summary Returns a paginated list of strings
         * @param {string} sha256 File SHA256
         * @param {number} [perPage] Number of strings per page
         * @param {number} [page] Specify the page number
         * @param {string} [q] Specify the string to search for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesSha256StringsGet(sha256: string, perPage?: number, page?: number, q?: string, options?: any): AxiosPromise<PaginationPages> {
            return localVarFp.filesSha256StringsGet(sha256, perPage, page, q, options).then((request) => request(axios, basePath));
        },
        /**
         * File metadata returned in the summary view of a file.
         * @summary File summary and metadata
         * @param {string} sha256 File SHA256
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesSha256SummaryGet(sha256: string, options?: any): AxiosPromise<PaginationPages> {
            return localVarFp.filesSha256SummaryGet(sha256, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes a file from the like list.
         * @summary Unlike a file
         * @param {string} sha256 File SHA256
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesSha256UnlikePost(sha256: string, options?: any): AxiosPromise<object> {
            return localVarFp.filesSha256UnlikePost(sha256, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FileApi - object-oriented interface
 * @export
 * @class FileApi
 * @extends {BaseAPI}
 */
export class FileApi extends BaseAPI {
    /**
     * List files
     * @summary Retrieves a paginated list of files
     * @param {number} [perPage] Number of files per page
     * @param {number} [page] Specify the page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public filesGet(perPage?: number, page?: number, options?: RawAxiosRequestConfig) {
        return FileApiFp(this.configuration).filesGet(perPage, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload file for analysis.
     * @summary Submit a new file for scanning
     * @param {File} file binary file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public filesPost(file: File, options?: RawAxiosRequestConfig) {
        return FileApiFp(this.configuration).filesPost(file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * File search autocomplete.
     * @summary Returns a list of file search autocomplete data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public filesSearchAutocompleteGet(options?: RawAxiosRequestConfig) {
        return FileApiFp(this.configuration).filesSearchAutocompleteGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search files
     * @summary Searches files based on files\' metadata
     * @param {number} [perPage] Number of files per page
     * @param {number} [page] Specify the page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public filesSearchPost(perPage?: number, page?: number, options?: RawAxiosRequestConfig) {
        return FileApiFp(this.configuration).filesSearchPost(perPage, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List of comments for a given file.
     * @summary Returns a paginated list of file comments
     * @param {string} sha256 File SHA256
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public filesSha256CommentsGet(sha256: string, options?: RawAxiosRequestConfig) {
        return FileApiFp(this.configuration).filesSha256CommentsGet(sha256, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a file by ID.
     * @summary Deletes a file
     * @param {string} sha256 File SHA256
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public filesSha256Delete(sha256: string, options?: RawAxiosRequestConfig) {
        return FileApiFp(this.configuration).filesSha256Delete(sha256, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Download a binary file. Files are in zip format and password protected.
     * @summary Download a file
     * @param {string} sha256 File SHA256
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public filesSha256DownloadGet(sha256: string, options?: RawAxiosRequestConfig) {
        return FileApiFp(this.configuration).filesSha256DownloadGet(sha256, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate a pre-signed URL to download samples directly from the object storage.
     * @summary Generate a pre-signed URL for downloading samples.
     * @param {string} sha256 File SHA256
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public filesSha256GeneratePresignedUrlPost(sha256: string, options?: RawAxiosRequestConfig) {
        return FileApiFp(this.configuration).filesSha256GeneratePresignedUrlPost(sha256, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the content of a file report.
     * @summary Get a file report
     * @param {string} sha256 File SHA256
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public filesSha256Get(sha256: string, options?: RawAxiosRequestConfig) {
        return FileApiFp(this.configuration).filesSha256Get(sha256, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check weather a file exists in the database.
     * @summary Check if a file exists.
     * @param {string} sha256 File SHA256
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public filesSha256Head(sha256: string, options?: RawAxiosRequestConfig) {
        return FileApiFp(this.configuration).filesSha256Head(sha256, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a file to the like list.
     * @summary Like a file
     * @param {string} sha256 File SHA256
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public filesSha256LikePost(sha256: string, options?: RawAxiosRequestConfig) {
        return FileApiFp(this.configuration).filesSha256LikePost(sha256, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Frontend metadata fields such as navbar menus.
     * @summary Frontend Metadata
     * @param {string} sha256 File SHA256
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public filesSha256MetaUiGet(sha256: string, options?: RawAxiosRequestConfig) {
        return FileApiFp(this.configuration).filesSha256MetaUiGet(sha256, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Patch a portion of a file report.
     * @summary Update a file report (partial update)
     * @param {string} sha256 File SHA256
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public filesSha256Patch(sha256: string, options?: RawAxiosRequestConfig) {
        return FileApiFp(this.configuration).filesSha256Patch(sha256, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace a file report with a new report
     * @summary Update a file report (full update)
     * @param {string} sha256 File SHA256
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public filesSha256Put(sha256: string, options?: RawAxiosRequestConfig) {
        return FileApiFp(this.configuration).filesSha256Put(sha256, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Rescan an existing file.
     * @summary Rescan an existing file
     * @param {string} sha256 File SHA256
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public filesSha256RescanPost(sha256: string, options?: RawAxiosRequestConfig) {
        return FileApiFp(this.configuration).filesSha256RescanPost(sha256, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List strings of a file.
     * @summary Returns a paginated list of strings
     * @param {string} sha256 File SHA256
     * @param {number} [perPage] Number of strings per page
     * @param {number} [page] Specify the page number
     * @param {string} [q] Specify the string to search for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public filesSha256StringsGet(sha256: string, perPage?: number, page?: number, q?: string, options?: RawAxiosRequestConfig) {
        return FileApiFp(this.configuration).filesSha256StringsGet(sha256, perPage, page, q, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * File metadata returned in the summary view of a file.
     * @summary File summary and metadata
     * @param {string} sha256 File SHA256
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public filesSha256SummaryGet(sha256: string, options?: RawAxiosRequestConfig) {
        return FileApiFp(this.configuration).filesSha256SummaryGet(sha256, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes a file from the like list.
     * @summary Unlike a file
     * @param {string} sha256 File SHA256
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public filesSha256UnlikePost(sha256: string, options?: RawAxiosRequestConfig) {
        return FileApiFp(this.configuration).filesSha256UnlikePost(sha256, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SupportApi - axios parameter creator
 * @export
 */
export const SupportApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Handles contact us form-data sent via landing page.
         * @summary Contact Us
         * @param {string} gRecaptchaResponse Google Recaptcha v3 response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactPost: async (gRecaptchaResponse: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gRecaptchaResponse' is not null or undefined
            assertParamExists('contactPost', 'gRecaptchaResponse', gRecaptchaResponse)
            const localVarPath = `/contact/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gRecaptchaResponse, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SupportApi - functional programming interface
 * @export
 */
export const SupportApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SupportApiAxiosParamCreator(configuration)
    return {
        /**
         * Handles contact us form-data sent via landing page.
         * @summary Contact Us
         * @param {string} gRecaptchaResponse Google Recaptcha v3 response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactPost(gRecaptchaResponse: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactPost(gRecaptchaResponse, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SupportApi.contactPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SupportApi - factory interface
 * @export
 */
export const SupportApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SupportApiFp(configuration)
    return {
        /**
         * Handles contact us form-data sent via landing page.
         * @summary Contact Us
         * @param {string} gRecaptchaResponse Google Recaptcha v3 response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactPost(gRecaptchaResponse: string, options?: any): AxiosPromise<object> {
            return localVarFp.contactPost(gRecaptchaResponse, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SupportApi - object-oriented interface
 * @export
 * @class SupportApi
 * @extends {BaseAPI}
 */
export class SupportApi extends BaseAPI {
    /**
     * Handles contact us form-data sent via landing page.
     * @summary Contact Us
     * @param {string} gRecaptchaResponse Google Recaptcha v3 response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SupportApi
     */
    public contactPost(gRecaptchaResponse: string, options?: RawAxiosRequestConfig) {
        return SupportApiFp(this.configuration).contactPost(gRecaptchaResponse, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List users.
         * @summary Retrieves a paginated list of users
         * @param {number} [perPage] Number of items per page
         * @param {number} [page] Specify the page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet: async (perPage?: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Bearer", [], configuration)

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new user.
         * @summary Create a new user
         * @param {UserCreateUserRequest} data User data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost: async (data: UserCreateUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('usersPost', 'data', data)
            const localVarPath = `/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change user avatar
         * @summary Update user avatar
         * @param {string} username Username
         * @param {UserUpdateEmailRequest} data User data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsernameAvatarPost: async (username: string, data: UserUpdateEmailRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('usersUsernameAvatarPost', 'username', username)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('usersUsernameAvatarPost', 'data', data)
            const localVarPath = `/users/{username}/avatar/`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Bearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of comments by a user.
         * @summary Returns a paginated list of a user\'s comments
         * @param {string} username Username
         * @param {number} [perPage] Number of items per page
         * @param {number} [page] Specify the page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsernameCommentsGet: async (username: string, perPage?: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('usersUsernameCommentsGet', 'username', username)
            const localVarPath = `/users/{username}/comments/`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Bearer", [], configuration)

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a user by ID.
         * @summary Deletes a user
         * @param {string} username Username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsernameDelete: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('usersUsernameDelete', 'username', username)
            const localVarPath = `/users/{username}/`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Bearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change email for logged-in users.
         * @summary Update email for authenticated users
         * @param {string} username Username
         * @param {UserUpdateEmailRequest} data User data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsernameEmailPost: async (username: string, data: UserUpdateEmailRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('usersUsernameEmailPost', 'username', username)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('usersUsernameEmailPost', 'data', data)
            const localVarPath = `/users/{username}/email/`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Bearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start following a user.
         * @summary Follow a user
         * @param {string} username Target user to follow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsernameFollowPost: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('usersUsernameFollowPost', 'username', username)
            const localVarPath = `/users/{username}/follow/`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Bearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of users who follow a user.
         * @summary Returns a paginated list of a user\'s followers
         * @param {string} username Username
         * @param {number} [perPage] Number of items per page
         * @param {number} [page] Specify the page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsernameFollowersGet: async (username: string, perPage?: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('usersUsernameFollowersGet', 'username', username)
            const localVarPath = `/users/{username}/followers/`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Bearer", [], configuration)

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of users a user follows.
         * @summary Returns a paginated list of a user\'s following
         * @param {string} username Username
         * @param {number} [perPage] Number of items per page
         * @param {number} [page] Specify the page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsernameFollowingGet: async (username: string, perPage?: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('usersUsernameFollowingGet', 'username', username)
            const localVarPath = `/users/{username}/following/`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Bearer", [], configuration)

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves information about a user.
         * @summary Get user information by user ID
         * @param {string} username User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsernameGet: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('usersUsernameGet', 'username', username)
            const localVarPath = `/users/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Bearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of likes of a user.
         * @summary Returns a paginated list of a user\'s likes
         * @param {string} username Username
         * @param {number} [perPage] Number of items per page
         * @param {number} [page] Specify the page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsernameLikesGet: async (username: string, perPage?: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('usersUsernameLikesGet', 'username', username)
            const localVarPath = `/users/{username}/likes/`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Bearer", [], configuration)

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change password for logged-in users.
         * @summary Update password for authenticated users
         * @param {string} username Username
         * @param {UserUpdateUserRequest} data User data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsernamePasswordPost: async (username: string, data: UserUpdateUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('usersUsernamePasswordPost', 'username', username)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('usersUsernamePasswordPost', 'data', data)
            const localVarPath = `/users/{username}/password/`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Bearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace a user document with a new user\'s document.
         * @summary Update a user object (full update)
         * @param {string} username Username
         * @param {UserUpdateUserRequest} data New user data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsernamePatch: async (username: string, data: UserUpdateUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('usersUsernamePatch', 'username', username)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('usersUsernamePatch', 'data', data)
            const localVarPath = `/users/{username}/`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Bearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of submissions by a user.
         * @summary Returns a paginated list of a user\'s submissions
         * @param {string} username Username
         * @param {number} [perPage] Number of items per page
         * @param {number} [page] Specify the page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsernameSubmissionsGet: async (username: string, perPage?: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('usersUsernameSubmissionsGet', 'username', username)
            const localVarPath = `/users/{username}/submissions/`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Bearer", [], configuration)

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stop following a user.
         * @summary Unfollow a user
         * @param {string} username Target user to unfollow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsernameUnfollowPost: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('usersUsernameUnfollowPost', 'username', username)
            const localVarPath = `/users/{username}/unfollow/`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Bearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * List users.
         * @summary Retrieves a paginated list of users
         * @param {number} [perPage] Number of items per page
         * @param {number} [page] Specify the page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersGet(perPage?: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersGet(perPage, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.usersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new user.
         * @summary Create a new user
         * @param {UserCreateUserRequest} data User data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPost(data: UserCreateUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPost(data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.usersPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change user avatar
         * @summary Update user avatar
         * @param {string} username Username
         * @param {UserUpdateEmailRequest} data User data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUsernameAvatarPost(username: string, data: UserUpdateEmailRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUsernameAvatarPost(username, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.usersUsernameAvatarPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List of comments by a user.
         * @summary Returns a paginated list of a user\'s comments
         * @param {string} username Username
         * @param {number} [perPage] Number of items per page
         * @param {number} [page] Specify the page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUsernameCommentsGet(username: string, perPage?: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationPages>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUsernameCommentsGet(username, perPage, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.usersUsernameCommentsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a user by ID.
         * @summary Deletes a user
         * @param {string} username Username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUsernameDelete(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUsernameDelete(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.usersUsernameDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change email for logged-in users.
         * @summary Update email for authenticated users
         * @param {string} username Username
         * @param {UserUpdateEmailRequest} data User data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUsernameEmailPost(username: string, data: UserUpdateEmailRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUsernameEmailPost(username, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.usersUsernameEmailPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Start following a user.
         * @summary Follow a user
         * @param {string} username Target user to follow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUsernameFollowPost(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUsernameFollowPost(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.usersUsernameFollowPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List of users who follow a user.
         * @summary Returns a paginated list of a user\'s followers
         * @param {string} username Username
         * @param {number} [perPage] Number of items per page
         * @param {number} [page] Specify the page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUsernameFollowersGet(username: string, perPage?: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationPages>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUsernameFollowersGet(username, perPage, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.usersUsernameFollowersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List of users a user follows.
         * @summary Returns a paginated list of a user\'s following
         * @param {string} username Username
         * @param {number} [perPage] Number of items per page
         * @param {number} [page] Specify the page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUsernameFollowingGet(username: string, perPage?: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationPages>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUsernameFollowingGet(username, perPage, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.usersUsernameFollowingGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves information about a user.
         * @summary Get user information by user ID
         * @param {string} username User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUsernameGet(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUsernameGet(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.usersUsernameGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List of likes of a user.
         * @summary Returns a paginated list of a user\'s likes
         * @param {string} username Username
         * @param {number} [perPage] Number of items per page
         * @param {number} [page] Specify the page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUsernameLikesGet(username: string, perPage?: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationPages>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUsernameLikesGet(username, perPage, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.usersUsernameLikesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change password for logged-in users.
         * @summary Update password for authenticated users
         * @param {string} username Username
         * @param {UserUpdateUserRequest} data User data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUsernamePasswordPost(username: string, data: UserUpdateUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUsernamePasswordPost(username, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.usersUsernamePasswordPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Replace a user document with a new user\'s document.
         * @summary Update a user object (full update)
         * @param {string} username Username
         * @param {UserUpdateUserRequest} data New user data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUsernamePatch(username: string, data: UserUpdateUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUsernamePatch(username, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.usersUsernamePatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List of submissions by a user.
         * @summary Returns a paginated list of a user\'s submissions
         * @param {string} username Username
         * @param {number} [perPage] Number of items per page
         * @param {number} [page] Specify the page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUsernameSubmissionsGet(username: string, perPage?: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationPages>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUsernameSubmissionsGet(username, perPage, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.usersUsernameSubmissionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Stop following a user.
         * @summary Unfollow a user
         * @param {string} username Target user to unfollow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUsernameUnfollowPost(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUsernameUnfollowPost(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.usersUsernameUnfollowPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * List users.
         * @summary Retrieves a paginated list of users
         * @param {number} [perPage] Number of items per page
         * @param {number} [page] Specify the page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet(perPage?: number, page?: number, options?: any): AxiosPromise<UsersGet200Response> {
            return localVarFp.usersGet(perPage, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new user.
         * @summary Create a new user
         * @param {UserCreateUserRequest} data User data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost(data: UserCreateUserRequest, options?: any): AxiosPromise<EntityUser> {
            return localVarFp.usersPost(data, options).then((request) => request(axios, basePath));
        },
        /**
         * Change user avatar
         * @summary Update user avatar
         * @param {string} username Username
         * @param {UserUpdateEmailRequest} data User data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsernameAvatarPost(username: string, data: UserUpdateEmailRequest, options?: any): AxiosPromise<object> {
            return localVarFp.usersUsernameAvatarPost(username, data, options).then((request) => request(axios, basePath));
        },
        /**
         * List of comments by a user.
         * @summary Returns a paginated list of a user\'s comments
         * @param {string} username Username
         * @param {number} [perPage] Number of items per page
         * @param {number} [page] Specify the page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsernameCommentsGet(username: string, perPage?: number, page?: number, options?: any): AxiosPromise<PaginationPages> {
            return localVarFp.usersUsernameCommentsGet(username, perPage, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a user by ID.
         * @summary Deletes a user
         * @param {string} username Username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsernameDelete(username: string, options?: any): AxiosPromise<EntityUser> {
            return localVarFp.usersUsernameDelete(username, options).then((request) => request(axios, basePath));
        },
        /**
         * Change email for logged-in users.
         * @summary Update email for authenticated users
         * @param {string} username Username
         * @param {UserUpdateEmailRequest} data User data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsernameEmailPost(username: string, data: UserUpdateEmailRequest, options?: any): AxiosPromise<object> {
            return localVarFp.usersUsernameEmailPost(username, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Start following a user.
         * @summary Follow a user
         * @param {string} username Target user to follow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsernameFollowPost(username: string, options?: any): AxiosPromise<object> {
            return localVarFp.usersUsernameFollowPost(username, options).then((request) => request(axios, basePath));
        },
        /**
         * List of users who follow a user.
         * @summary Returns a paginated list of a user\'s followers
         * @param {string} username Username
         * @param {number} [perPage] Number of items per page
         * @param {number} [page] Specify the page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsernameFollowersGet(username: string, perPage?: number, page?: number, options?: any): AxiosPromise<PaginationPages> {
            return localVarFp.usersUsernameFollowersGet(username, perPage, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List of users a user follows.
         * @summary Returns a paginated list of a user\'s following
         * @param {string} username Username
         * @param {number} [perPage] Number of items per page
         * @param {number} [page] Specify the page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsernameFollowingGet(username: string, perPage?: number, page?: number, options?: any): AxiosPromise<PaginationPages> {
            return localVarFp.usersUsernameFollowingGet(username, perPage, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves information about a user.
         * @summary Get user information by user ID
         * @param {string} username User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsernameGet(username: string, options?: any): AxiosPromise<EntityUser> {
            return localVarFp.usersUsernameGet(username, options).then((request) => request(axios, basePath));
        },
        /**
         * List of likes of a user.
         * @summary Returns a paginated list of a user\'s likes
         * @param {string} username Username
         * @param {number} [perPage] Number of items per page
         * @param {number} [page] Specify the page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsernameLikesGet(username: string, perPage?: number, page?: number, options?: any): AxiosPromise<PaginationPages> {
            return localVarFp.usersUsernameLikesGet(username, perPage, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Change password for logged-in users.
         * @summary Update password for authenticated users
         * @param {string} username Username
         * @param {UserUpdateUserRequest} data User data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsernamePasswordPost(username: string, data: UserUpdateUserRequest, options?: any): AxiosPromise<object> {
            return localVarFp.usersUsernamePasswordPost(username, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace a user document with a new user\'s document.
         * @summary Update a user object (full update)
         * @param {string} username Username
         * @param {UserUpdateUserRequest} data New user data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsernamePatch(username: string, data: UserUpdateUserRequest, options?: any): AxiosPromise<EntityUser> {
            return localVarFp.usersUsernamePatch(username, data, options).then((request) => request(axios, basePath));
        },
        /**
         * List of submissions by a user.
         * @summary Returns a paginated list of a user\'s submissions
         * @param {string} username Username
         * @param {number} [perPage] Number of items per page
         * @param {number} [page] Specify the page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsernameSubmissionsGet(username: string, perPage?: number, page?: number, options?: any): AxiosPromise<PaginationPages> {
            return localVarFp.usersUsernameSubmissionsGet(username, perPage, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Stop following a user.
         * @summary Unfollow a user
         * @param {string} username Target user to unfollow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsernameUnfollowPost(username: string, options?: any): AxiosPromise<object> {
            return localVarFp.usersUsernameUnfollowPost(username, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * List users.
     * @summary Retrieves a paginated list of users
     * @param {number} [perPage] Number of items per page
     * @param {number} [page] Specify the page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersGet(perPage?: number, page?: number, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).usersGet(perPage, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new user.
     * @summary Create a new user
     * @param {UserCreateUserRequest} data User data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersPost(data: UserCreateUserRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).usersPost(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change user avatar
     * @summary Update user avatar
     * @param {string} username Username
     * @param {UserUpdateEmailRequest} data User data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersUsernameAvatarPost(username: string, data: UserUpdateEmailRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).usersUsernameAvatarPost(username, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List of comments by a user.
     * @summary Returns a paginated list of a user\'s comments
     * @param {string} username Username
     * @param {number} [perPage] Number of items per page
     * @param {number} [page] Specify the page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersUsernameCommentsGet(username: string, perPage?: number, page?: number, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).usersUsernameCommentsGet(username, perPage, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a user by ID.
     * @summary Deletes a user
     * @param {string} username Username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersUsernameDelete(username: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).usersUsernameDelete(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change email for logged-in users.
     * @summary Update email for authenticated users
     * @param {string} username Username
     * @param {UserUpdateEmailRequest} data User data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersUsernameEmailPost(username: string, data: UserUpdateEmailRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).usersUsernameEmailPost(username, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start following a user.
     * @summary Follow a user
     * @param {string} username Target user to follow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersUsernameFollowPost(username: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).usersUsernameFollowPost(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List of users who follow a user.
     * @summary Returns a paginated list of a user\'s followers
     * @param {string} username Username
     * @param {number} [perPage] Number of items per page
     * @param {number} [page] Specify the page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersUsernameFollowersGet(username: string, perPage?: number, page?: number, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).usersUsernameFollowersGet(username, perPage, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List of users a user follows.
     * @summary Returns a paginated list of a user\'s following
     * @param {string} username Username
     * @param {number} [perPage] Number of items per page
     * @param {number} [page] Specify the page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersUsernameFollowingGet(username: string, perPage?: number, page?: number, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).usersUsernameFollowingGet(username, perPage, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves information about a user.
     * @summary Get user information by user ID
     * @param {string} username User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersUsernameGet(username: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).usersUsernameGet(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List of likes of a user.
     * @summary Returns a paginated list of a user\'s likes
     * @param {string} username Username
     * @param {number} [perPage] Number of items per page
     * @param {number} [page] Specify the page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersUsernameLikesGet(username: string, perPage?: number, page?: number, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).usersUsernameLikesGet(username, perPage, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change password for logged-in users.
     * @summary Update password for authenticated users
     * @param {string} username Username
     * @param {UserUpdateUserRequest} data User data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersUsernamePasswordPost(username: string, data: UserUpdateUserRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).usersUsernamePasswordPost(username, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace a user document with a new user\'s document.
     * @summary Update a user object (full update)
     * @param {string} username Username
     * @param {UserUpdateUserRequest} data New user data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersUsernamePatch(username: string, data: UserUpdateUserRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).usersUsernamePatch(username, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List of submissions by a user.
     * @summary Returns a paginated list of a user\'s submissions
     * @param {string} username Username
     * @param {number} [perPage] Number of items per page
     * @param {number} [page] Specify the page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersUsernameSubmissionsGet(username: string, perPage?: number, page?: number, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).usersUsernameSubmissionsGet(username, perPage, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Stop following a user.
     * @summary Unfollow a user
     * @param {string} username Target user to unfollow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersUsernameUnfollowPost(username: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).usersUsernameUnfollowPost(username, options).then((request) => request(this.axios, this.basePath));
    }
}



